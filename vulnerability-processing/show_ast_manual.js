// helper script to show AST in format needed by finder.js
// 1. find commit of vulnerability
// 2. create structure of variables input, escapedInput, inputAst, patch, escapedPatch
// 3. copy code of 'before' to input, 'after' to patch
// 4. use https://www.freeformatter.com/ to fill escapedInput and escapedPatch
// 5. set showAstOnly to true, run
// 6. copy inputAst from console, remove unwanted nodes (Program, perhaps others, depends on specific case)
// 7. set showAstOnly to false
// 8. use hashes from console (in js-to-ast run.js add patches and vulnerabilities)


const finder = require("../js-to-ast/src/finder");

var showAstOnly = false;

function showAst(escapedInput) {
    var inputAst = finder.tryParse(escapedInput);
    console.log(JSON.stringify(inputAst, (k, v) => (k === 'start' || k === 'end' || k === 'sourceType') ? undefined : v));
}

function computeHashes(inputAst, escPatch) {
    let inputAstHashCrypto = finder.crypto.SHA1(JSON.stringify(inputAst, (k, v) => (k === 'start' || k === 'end' || k === 'sourceType') ? undefined : v));

    console.log('input: ' + inputAstHashCrypto.toString());

    if (escPatch) {
        let patchAst = finder.tryParse(escPatch);
        let patchAstHashCrypto = finder.crypto.SHA1(JSON.stringify(patchAst));
        console.log('patch: ' + patchAstHashCrypto.toString());
    }

    console.log('\n');
}

// https://github.com/advisories/GHSA-2pqj-h3vj-pqgw
// https://github.com/jquery/jquery/commit/f71a6ec6cfe3f748a939eaa109e92b8a9bdac6cc
var input = `/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/`;
var escapedInput = `\/^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)\/`;
var inputAst = { "type": "Literal", "value": {}, "raw": "/^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/", "regex": { "pattern": "^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)", "flags": "" } };
var patch = `/^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/`;
var escapedPatch = `\/^(?:(<[\\w\\W]+>)[^>]*|#([\\w-]*))$\/`;
showAstOnly ? showAst(escapedInput) : computeHashes(inputAst, escapedPatch);

// https://github.com/advisories/GHSA-2pqj-h3vj-pqgw
// https://github.com/jquery/jquery/commit/0877d424e08d57e6f0d1da9a86289fb10d0ee136
input = `/^(?:[^#<]*(<[\w\W]+>)[^>]*$)/`;
escapedInput = `\/^(?:[^#<]*(<[\\w\\W]+>)[^>]*$)\/`;
inputAst = { "type": "Literal", "value": {}, "raw": "/^(?:[^#<]*(<[\\w\\W]+>)[^>]*$)/", "regex": { "pattern": "^(?:[^#<]*(<[\\w\\W]+>)[^>]*$)", "flags": "" } };
patch = `/^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/`;
escapedPatch = `\/^(?:(<[\\w\\W]+>)[^>]*|#([\\w-]*))$\/`;
showAstOnly ? showAst(escapedInput) : computeHashes(inputAst, escapedPatch);

// https://github.com/advisories/GHSA-2pqj-h3vj-pqgw
// https://github.com/jquery/jquery/commit/05531fc4080ae24070930d15ae0cea7ae056457d
input = `/^(?:[^#<]*(<[\w\W]+>)[^>]*|#([\w-]*))$/`;
escapedInput = `\/^(?:[^#<]*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$\/`;
inputAst = { "type": "Literal", "value": {}, "raw": "/^(?:[^#<]*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/", "regex": { "pattern": "^(?:[^#<]*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$", "flags": "" } };
patch = `/^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/`;
escapedPatch = `\/^(?:(<[\\w\\W]+>)[^>]*|#([\\w-]*))$\/`
showAstOnly ? showAst(escapedInput) : computeHashes(inputAst, escapedPatch);

// https://github.com/advisories/GHSA-gxr4-xjj5-5px2
input = `/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi`;
escapedInput = `\/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\\/>\/gi`;
inputAst = { "type": "Literal", "value": {}, "raw": "/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi", "regex": { "pattern": "<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>", "flags": "gi" } };
showAstOnly ? showAst(escapedInput) : computeHashes(inputAst, null);


// https://github.com/advisories/GHSA-x5rq-j2xg-h7qm
input = `/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/`;
escapedInput = `\/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]\/`;
inputAst = { "type": "Literal", "value": {}, "raw": "/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/", "regex": { "pattern": "[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]", "flags": "" } };
patch = `/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/`;
escapedPatch = `\/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]\/`
showAstOnly ? showAst(escapedInput) : computeHashes(inputAst, escapedPatch);

// https://github.com/advisories/GHSA-446m-mv8f-q348
input = `/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i`;
escapedInput = `\/[0-9]*[\'a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}\/i`;
inputAst = { "type": "Literal", "value": {}, "raw": "/[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i", "regex": { "pattern": "[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}", "flags": "i" } };
patch = `/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i`;
escapedPatch = `\/[0-9]*[\'a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}\/i`
showAstOnly ? showAst(escapedInput) : computeHashes(inputAst, escapedPatch);

// https://github.com/advisories/GHSA-6c3j-c64m-qhgq
input = `for ( ; i < length; i++ ) {
    // Only deal with non-null/undefined values
    if ( ( options = arguments[ i ] ) != null ) {
        // Extend the base object
        for ( name in options ) {
            copy = options[ name ];

            // Prevent never-ending loop
            if ( target === copy ) {
                continue;
            }

            // Recurse if we're merging plain objects or arrays
            if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
                ( copyIsArray = Array.isArray( copy ) ) ) ) {
                src = target[ name ];
                // Ensure proper type for the source value
                if ( copyIsArray && !Array.isArray( src ) ) {
                    clone = [];
                } else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
                    clone = {};
                } else {
                    clone = src;
                }
                copyIsArray = false;
                // Never move original objects, clone them
                target[ name ] = jQuery.extend( deep, clone, copy );
            // Don't bring in undefined values
            } else if ( copy !== undefined ) {
                target[ name ] = copy;
            }
        }
    }
}`;
escapedInput = `for ( ; i < length; i++ ) {\r\n\t\t\/\/ Only deal with non-null\/undefined values\r\n\t\tif ( ( options = arguments[ i ] ) != null ) {\r\n\t\t\t\/\/ Extend the base object\r\n\t\t\tfor ( name in options ) {\r\n\t\t\t\tcopy = options[ name ];\r\n\r\n\t\t\t\t\/\/ Prevent never-ending loop\r\n\t\t\t\tif ( target === copy ) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t\/\/ Recurse if we\'re merging plain objects or arrays\r\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\r\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\r\n\t\t\t\t\tsrc = target[ name ];\r\n\t\t\t\t\t\/\/ Ensure proper type for the source value\r\n\t\t\t\t\tif ( copyIsArray && !Array.isArray( src ) ) {\r\n\t\t\t\t\t\tclone = [];\r\n\t\t\t\t\t} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {\r\n\t\t\t\t\t\tclone = {};\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tclone = src;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcopyIsArray = false;\r\n\t\t\t\t\t\/\/ Never move original objects, clone them\r\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\r\n\t\t\t\t\/\/ Don\'t bring in undefined values\r\n\t\t\t\t} else if ( copy !== undefined ) {\r\n\t\t\t\t\ttarget[ name ] = copy;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}`;
inputAst = { "type": "ForStatement", "init": null, "test": { "type": "BinaryExpression", "left": { "type": "Identifier", "name": "i" }, "operator": "<", "right": { "type": "Identifier", "name": "length" } }, "update": { "type": "UpdateExpression", "operator": "++", "prefix": false, "argument": { "type": "Identifier", "name": "i" } }, "body": { "type": "BlockStatement", "body": [{ "type": "IfStatement", "test": { "type": "BinaryExpression", "left": { "type": "AssignmentExpression", "operator": "=", "left": { "type": "Identifier", "name": "options" }, "right": { "type": "MemberExpression", "object": { "type": "Identifier", "name": "arguments" }, "property": { "type": "Identifier", "name": "i" }, "computed": true, "optional": false } }, "operator": "!=", "right": { "type": "Literal", "value": null, "raw": "null" } }, "consequent": { "type": "BlockStatement", "body": [{ "type": "ForInStatement", "left": { "type": "Identifier", "name": "name" }, "right": { "type": "Identifier", "name": "options" }, "body": { "type": "BlockStatement", "body": [{ "type": "ExpressionStatement", "expression": { "type": "AssignmentExpression", "operator": "=", "left": { "type": "Identifier", "name": "copy" }, "right": { "type": "MemberExpression", "object": { "type": "Identifier", "name": "options" }, "property": { "type": "Identifier", "name": "name" }, "computed": true, "optional": false } } }, { "type": "IfStatement", "test": { "type": "BinaryExpression", "left": { "type": "Identifier", "name": "target" }, "operator": "===", "right": { "type": "Identifier", "name": "copy" } }, "consequent": { "type": "BlockStatement", "body": [{ "type": "ContinueStatement", "label": null }] }, "alternate": null }, { "type": "IfStatement", "test": { "type": "LogicalExpression", "left": { "type": "LogicalExpression", "left": { "type": "Identifier", "name": "deep" }, "operator": "&&", "right": { "type": "Identifier", "name": "copy" } }, "operator": "&&", "right": { "type": "LogicalExpression", "left": { "type": "CallExpression", "callee": { "type": "MemberExpression", "object": { "type": "Identifier", "name": "jQuery" }, "property": { "type": "Identifier", "name": "isPlainObject" }, "computed": false, "optional": false }, "arguments": [{ "type": "Identifier", "name": "copy" }], "optional": false }, "operator": "||", "right": { "type": "AssignmentExpression", "operator": "=", "left": { "type": "Identifier", "name": "copyIsArray" }, "right": { "type": "CallExpression", "callee": { "type": "MemberExpression", "object": { "type": "Identifier", "name": "Array" }, "property": { "type": "Identifier", "name": "isArray" }, "computed": false, "optional": false }, "arguments": [{ "type": "Identifier", "name": "copy" }], "optional": false } } } }, "consequent": { "type": "BlockStatement", "body": [{ "type": "ExpressionStatement", "expression": { "type": "AssignmentExpression", "operator": "=", "left": { "type": "Identifier", "name": "src" }, "right": { "type": "MemberExpression", "object": { "type": "Identifier", "name": "target" }, "property": { "type": "Identifier", "name": "name" }, "computed": true, "optional": false } } }, { "type": "IfStatement", "test": { "type": "LogicalExpression", "left": { "type": "Identifier", "name": "copyIsArray" }, "operator": "&&", "right": { "type": "UnaryExpression", "operator": "!", "prefix": true, "argument": { "type": "CallExpression", "callee": { "type": "MemberExpression", "object": { "type": "Identifier", "name": "Array" }, "property": { "type": "Identifier", "name": "isArray" }, "computed": false, "optional": false }, "arguments": [{ "type": "Identifier", "name": "src" }], "optional": false } } }, "consequent": { "type": "BlockStatement", "body": [{ "type": "ExpressionStatement", "expression": { "type": "AssignmentExpression", "operator": "=", "left": { "type": "Identifier", "name": "clone" }, "right": { "type": "ArrayExpression", "elements": [] } } }] }, "alternate": { "type": "IfStatement", "test": { "type": "LogicalExpression", "left": { "type": "UnaryExpression", "operator": "!", "prefix": true, "argument": { "type": "Identifier", "name": "copyIsArray" } }, "operator": "&&", "right": { "type": "UnaryExpression", "operator": "!", "prefix": true, "argument": { "type": "CallExpression", "callee": { "type": "MemberExpression", "object": { "type": "Identifier", "name": "jQuery" }, "property": { "type": "Identifier", "name": "isPlainObject" }, "computed": false, "optional": false }, "arguments": [{ "type": "Identifier", "name": "src" }], "optional": false } } }, "consequent": { "type": "BlockStatement", "body": [{ "type": "ExpressionStatement", "expression": { "type": "AssignmentExpression", "operator": "=", "left": { "type": "Identifier", "name": "clone" }, "right": { "type": "ObjectExpression", "properties": [] } } }] }, "alternate": { "type": "BlockStatement", "body": [{ "type": "ExpressionStatement", "expression": { "type": "AssignmentExpression", "operator": "=", "left": { "type": "Identifier", "name": "clone" }, "right": { "type": "Identifier", "name": "src" } } }] } } }, { "type": "ExpressionStatement", "expression": { "type": "AssignmentExpression", "operator": "=", "left": { "type": "Identifier", "name": "copyIsArray" }, "right": { "type": "Literal", "value": false, "raw": "false" } } }, { "type": "ExpressionStatement", "expression": { "type": "AssignmentExpression", "operator": "=", "left": { "type": "MemberExpression", "object": { "type": "Identifier", "name": "target" }, "property": { "type": "Identifier", "name": "name" }, "computed": true, "optional": false }, "right": { "type": "CallExpression", "callee": { "type": "MemberExpression", "object": { "type": "Identifier", "name": "jQuery" }, "property": { "type": "Identifier", "name": "extend" }, "computed": false, "optional": false }, "arguments": [{ "type": "Identifier", "name": "deep" }, { "type": "Identifier", "name": "clone" }, { "type": "Identifier", "name": "copy" }], "optional": false } } }] }, "alternate": { "type": "IfStatement", "test": { "type": "BinaryExpression", "left": { "type": "Identifier", "name": "copy" }, "operator": "!==", "right": { "type": "Identifier", "name": "undefined" } }, "consequent": { "type": "BlockStatement", "body": [{ "type": "ExpressionStatement", "expression": { "type": "AssignmentExpression", "operator": "=", "left": { "type": "MemberExpression", "object": { "type": "Identifier", "name": "target" }, "property": { "type": "Identifier", "name": "name" }, "computed": true, "optional": false }, "right": { "type": "Identifier", "name": "copy" } } }] }, "alternate": null } }] } }] }, "alternate": null }] } };
patch = `for ( ; i < length; i++ ) {
    // Only deal with non-null/undefined values
    if ( ( options = arguments[ i ] ) != null ) {
        // Extend the base object
        for ( name in options ) {
            copy = options[ name ];

            // Prevent Object.prototype pollution
            // Prevent never-ending loop
            if ( name === "__proto__" || target === copy ) {
                continue;
            }

            // Recurse if we're merging plain objects or arrays
            if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
                ( copyIsArray = Array.isArray( copy ) ) ) ) {
                src = target[ name ];
                // Ensure proper type for the source value
                if ( copyIsArray && !Array.isArray( src ) ) {
                    clone = [];
                } else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
                    clone = {};
                } else {
                    clone = src;
                }
                copyIsArray = false;
                // Never move original objects, clone them
                target[ name ] = jQuery.extend( deep, clone, copy );
            // Don't bring in undefined values
            } else if ( copy !== undefined ) {
                target[ name ] = copy;
            }
        }
    }
}`;
escapedPatch = `for ( ; i < length; i++ ) {\r\n\t\t\/\/ Only deal with non-null\/undefined values\r\n\t\tif ( ( options = arguments[ i ] ) != null ) {\r\n\t\t\t\/\/ Extend the base object\r\n\t\t\tfor ( name in options ) {\r\n\t\t\t\tcopy = options[ name ];\r\n\r\n\t\t\t\t\/\/ Prevent Object.prototype pollution\r\n\t\t\t\t\/\/ Prevent never-ending loop\r\n\t\t\t\tif ( name === \"__proto__\" || target === copy ) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t\/\/ Recurse if we\'re merging plain objects or arrays\r\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\r\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\r\n\t\t\t\t\tsrc = target[ name ];\r\n\t\t\t\t\t\/\/ Ensure proper type for the source value\r\n\t\t\t\t\tif ( copyIsArray && !Array.isArray( src ) ) {\r\n\t\t\t\t\t\tclone = [];\r\n\t\t\t\t\t} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {\r\n\t\t\t\t\t\tclone = {};\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tclone = src;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcopyIsArray = false;\r\n\t\t\t\t\t\/\/ Never move original objects, clone them\r\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\r\n\t\t\t\t\/\/ Don\'t bring in undefined values\r\n\t\t\t\t} else if ( copy !== undefined ) {\r\n\t\t\t\t\ttarget[ name ] = copy;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}`;
showAstOnly ? showAst(escapedInput) : computeHashes(inputAst, escapedPatch);
